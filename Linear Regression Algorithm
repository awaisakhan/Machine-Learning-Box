#Below is a sequence of commands to model a Linear Regression algorithm on noisy data using TensorFlow


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
%matplotlib inline

#create linear data and add random noise to the y_values
x_values = np.linspace (0, 10, 10000)
y_values = (2 * x_values) + 3 + np.random.randn(len(x_values)) #generating linear data with noise
data_set = pd.concat([pd.DataFrame(data=x_values,columns=['X Axis']),pd.DataFrame(data=y_values,columns=['Y Axis'])],axis=1)
data_set.sample(n=200).plot(kind = 'scatter', x='X Axis', y ='Y Axis')

import tensorflow as tf

batch_size = 10         #pick batches of 10 points

#set variables on slope and y-intercept
m = tf.Variable(0.2)    
b = tf.Variable(0.9)

#set placeholders on x and y
xph = tf.placeholder(tf.float32, [batch_size])
yph = tf.placeholder(tf.float32, [batch_size])

#find modeled value of y
y_model = m*xph + b

#use the difference in y to find the error loss function
error = tf.reduce_sum(tf.square(yph-y_model))

#optimize and train
optimizer = tf.train.GradientDescentOptimizer(learning_rate=0.001)
trainer = optimizer.minimize(error)
init = tf.global_variables_initializer()

#run session on 1000 batches of 10. generate random indices, save placeholder values and feed to the trainer
with tf.Session() as sess:
    
    sess.run(init)
    batch_no = 1000
    
    for i in range(batch_no):
        
        random_index = np.random.randint(len(x_values), size = batch_size)
        
        feed_ph = {xph : x_values[random_index], yph : y_values[random_index]}
        
        sess.run(trainer, feed_ph)
        
    new_m, new_b = sess.run([m,b])
    
#Plot final results including noisy data's scatter plot and predicted linear relation
y_pred = x_values * new_m + new_b
data_set.sample(n=200).plot(kind = 'scatter', x='X Axis', y ='Y Axis')
plt.plot(x_values, y_pred, 'r--')
